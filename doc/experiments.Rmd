---
title: "Experiments on dataset and EM"
output: html_notebook
---

This notebook contains some experiments to figure out how the dataset will be used (based on in-class tutorials), and how we'll implement the EM algorithm to compute the clusters.

```{r}
source("../lib/functions.R")
```


```{r}
movie_train <- read.csv("../data/eachmovie_sample/data_train.csv", as.is = TRUE, header = TRUE)
MS_train <- read.csv("../data/MS_sample/data_train.csv", as.is = TRUE, header = TRUE)
```

```{r}
system.time(MS_UI <- MS_data_transform(MS_train))
system.time(movies_UI <- movie_data_transform(movie_train))

save(MS_UI, file = "../data/ms_UI.RData")
save(movies_UI, file = "../data/movies_UI.RData")
```

```{r}
load("../data/ms_UI.RData")
load("../data/movies_UI.RData")
```


```{r}
dim(movies_UI)
```

# Important note

Each row of the matrix movies_UI corresponds to a user. Yet, not all users are in this matrix.
If we access a row through movies_UI[i,] with i an integer, we will get the ratings for the ith user in the matrix, not user number i.
If we want to access this user's rating correctly, we need to use a string instead:

```{r}
head(movies_UI)
movies_UI[2,] # gives ratings of 2nd user in matrix which is in fact user 23
movies_UI["23",] # gives ratings of user 23 (which is 2nd user in this matrix)
```

We don't have this issue for movies though.



Check if there are movies that have no rating, if it's the case we'll have to deal with these cases:

```{r}
# there's probably a cleaner way to check that
for (j in 1:1619){
  if (all(is.na(movies_UI[,j]))){
    print(j)
  }
}
```

For test purposes we reduce the size of movies_UI:
If we simply shrink the matrix, we might end up with movies that have only NA ratings, so we need to remove them:

```{r}
# same as above, ugly code
movies_UI <- movies_UI[1:500,1:200]
non_na_columns = matrix(TRUE, 200)

for (j in 1:200){
  if (all(is.na(movies_UI[,j]))){
    non_na_columns[j] = FALSE
  }
}

movies_UI <- movies_UI[,which(non_na_columns)]
```


# Hyperparameters

```{r}
C <- 3 # number of classes, will be tuned later
# n_users <- max(as.numeric(rownames(movies_UI)))
n_users <- dim(movies_UI)[1]
n_items <- dim(movies_UI)[2]
```

# Notations

μˆc on the  slides <=> prob_class[c] with c (class index) an integer
γˆjk on the slides <=> prob_rating[c,j,k] with c (class index), j (movie index / website index) and k (rating) integers


# Step 1: Initiate Parameter Estimates

Choose uniform values for the initial estimates μˆc,γˆjk,c:

```{r}
prob_class <- matrix(1/C, nrow=C)
prob_rating <- array(1/6, dim=c(C, n_items, 6))
assignment <- matrix(NA, nrow=n_users, ncol=C)
```

# Step 2: Expectation Step

Recompute assignment matrix *assignment* for c = 1,2,...,C and i = 1,2,...,n_users:

There's a main issue which is that the formula to update the assignment (slide 42) involves products of many small probabilities (around 0.1). Therefore we quickly reach the smallest float precision in R and the product is approximated to 0 (minimal precision in R is 2e-308). We can't use log to solve this problem since the denominator is a sum....

```{r}
# old fix: subsampling movies

# update_assignment <- function(assignment, prob_class, prob_rating){
#   for (i in 1:n_users){
#     for (c in 1:C){
#       movies_rated_by_i <- which(!is.na(movies_UI[i,]))
#       ratings_given_by_i <- movies_UI[i,!is.na(movies_UI[i,])] 
#       
#       # fix for now: sample some movies instead of all:
#       if (length(movies_rated_by_i) > 100){
#         movies_subsample <- sample(length(movies_rated_by_i),size=100,replace=FALSE)
#         movies_rated_by_i <- movies_rated_by_i[movies_subsample]
#         ratings_given_by_i <- ratings_given_by_i[movies_subsample]
#       }
#       
#       numerator <- prob_class[c]
#       for (k in 1:length(movies_rated_by_i)){
#         numerator <- numerator * prob_rating[c, movies_rated_by_i[[k]], ratings_given_by_i[[k]]]
#       }
#       # print(numerator)
#       denominator <- 0
#       for (l in 1:C){
#         prod <- prob_class[l]
#         for (k in 1:length(movies_rated_by_i)){
#           prod <- prod * prob_rating[l, movies_rated_by_i[[k]], ratings_given_by_i[[k]]]
#         }
#         denominator <- denominator + prod
#       }
#       if (denominator == 0){
#         print('problem')
#         print(c(c,i))
#       }
#       assignment[i, c] <- numerator/denominator
#     }
#   }
#   return(assignment)
# }
```

One solution seems to be scaling prob_rating to mean=1 before computing the products:

```{r}
update_assignment <- function(assignment, prob_class, prob_rating){
  # trick: prob_rating contains floats between 0 and 1
  # since we do a products of a lot of these floats, we'll underflow at some point
  # to fix this scale prob_rating (to mean=1) initially
  # since we're taking ratios eventually this is still correct.
  prob_rating <- prob_rating/mean(prob_rating)
  for (i in 1:n_users){
    for (c in 1:C){
      movies_rated_by_i <- which(!is.na(movies_UI[i,]))
      ratings_given_by_i <- movies_UI[i,!is.na(movies_UI[i,])]

      numerator <- prob_class[c]
      for (k in 1:length(movies_rated_by_i)){
        numerator <- numerator * prob_rating[c, movies_rated_by_i[[k]], ratings_given_by_i[[k]]]
      }
      # print(numerator)
      denominator <- 0
      for (l in 1:C){
        prod <- prob_class[l]
        for (k in 1:length(movies_rated_by_i)){
          prod <- prod * prob_rating[l, movies_rated_by_i[[k]], ratings_given_by_i[[k]]]
        }
        denominator <- denominator + prod
      }
      if (denominator == 0 | is.na(denominator)){
        print('problem')
        print(c(c,i))
      }
      if (is.na(numerator)){
        print('problem too')
        print(c(c,i))
      }
      if (is.na(numerator/denominator)){
        print('problem again')
        print(c(c,i))
      }
      assignment[i, c] <- numerator/denominator
    }
  }
  return(assignment)
}
```

# Step 3: Maximization Step

Recompute parameters estimates *prob_class* for c=1..C and *prob_rating* for all c,j,k.

```{r}
update_prob_class <- function(prob_class, assignment){
  for (c in 1:C){
    prob_class[c,] <- sum(assignment[!is.na(assignment[,c]),c])/n_users
  }
  return(prob_class)
}

update_prob_rating <- function(prob_rating, assignment)
  for (c in 1:C){
    for (j in 1:n_items){
      users_who_rated_item_j <- which(!is.na(movies_UI[,j]))
      # print('---------')
      # print(c(c,j))
      # print(users_who_rated_item_j)
      denominator <- sum(assignment[users_who_rated_item_j,c])
      # warning: denominator can be = 0 ! (if prob_class got to 0 for class c at previous step)
      # print(denominator)
      for(k in 1:6){
        if (denominator != 0){
          numerator <- sum((movies_UI[users_who_rated_item_j,j] == k) * assignment[users_who_rated_item_j,c])
          prob_rating[c,j,k] <- numerator/denominator
        } else{
          prob_rating[c,j,k] <- 0
        }
      }
    }
  return(prob_rating)
}
```


# Test the algorithm:

```{r}
prob_class <- matrix(1/C, nrow=C)
prob_rating <- array(1/6, dim=c(C, n_items, 6))
assignment <- matrix(NA, nrow=n_users, ncol=C)

assignment <- update_assignment(assignment, prob_class, prob_rating)
```


```{r}
em <- function(steps){
  # TODO: add checking of convergence
  prob_class <- matrix(1/C, nrow=C)
  prob_rating <- array(1/6, dim=c(C, n_items, 6))
  assignment <- matrix(NA, nrow=n_users, ncol=C)

  for (i in 1:steps){
    # E:
    assignment <- update_assignment(assignment, prob_class, prob_rating)

    # M:
    prob_class <- update_prob_class(prob_class, assignment)
    prob_rating <- update_prob_rating(prob_rating, assignment)
  }
  return(list(assignment, prob_class, prob_rating))
}

system.time(result <- em(200)) # 500 sec ~ 8 min

assignment <- result[[1]]
prob_class <- result[[2]]
prob_rating <- result[[3]]
```


# Check results:

```{r}
for (i in 1:dim(assignment)[1]){
  stopifnot(abs(sum(assignment[i,]) - 1) < 0.001)
}
```



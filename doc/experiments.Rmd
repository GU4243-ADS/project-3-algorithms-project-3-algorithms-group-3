---
title: "Experiments on dataset and EM"
output: html_notebook
---

This notebook contains some experiments to figure out how the dataset will be used (based on in-class tutorials), and how we'll implement the EM algorithm to compute the clusters.

```{r}
source("../lib/functions.R")
```


```{r}
movie_train <- read.csv("../data/eachmovie_sample/data_train.csv", as.is = TRUE, header = TRUE)
MS_train <- read.csv("../data/MS_sample/data_train.csv", as.is = TRUE, header = TRUE)
```

```{r}
system.time(MS_UI <- MS_data_transform(MS_train))
system.time(movies_UI <- movie_data_transform(movie_train))

save(MS_UI, file = "../data/ms_UI.RData")
save(movies_UI, file = "../data/movies_UI.RData")
```

```{r}
load("../data/ms_UI.RData")
load("../data/movies_UI.RData")
```


```{r}
dim(movies_UI)
```

# Important note

Each row of the matrix movies_UI corresponds to a user. Yet, not all users are in this matrix.
If we access a row through movies_UI[i,] with i an integer, we will get the ratings for the ith user in the matrix, not user number i.
If we want to access this user's rating correctly, we need to use a string instead:

```{r}
head(movies_UI)
movies_UI[2,] # gives ratings of 2nd user in matrix which is in fact user 23
movies_UI["23",] # gives ratings of user 23 (which is 2nd user in this matrix)
```

We don't have this issue for movies though.



Check if there are movies that have no rating, if it's the case we'll have to deal with these cases:

```{r}
# there's probably a cleaner way to check that
for (j in 1:1619){
  if (all(is.na(movies_UI[,j]))){
    print(j)
  }
}
```

For test purposes we reduce the size of movies_UI:
If we simply shrink the matrix, we might end up with movies that have only NA ratings, so we need to remove them:

```{r}
# same as above, ugly code
movies_UI <- movies_UI[1:500,1:200]
non_na_columns = matrix(TRUE, 200)

for (j in 1:200){
  if (all(is.na(movies_UI[,j]))){
    non_na_columns[j] = FALSE
  }
}

movies_UI <- movies_UI[,which(non_na_columns)]
```


# Hyperparameters

```{r}
C <- 3 # number of classes, will be tuned later
# n_users <- max(as.numeric(rownames(movies_UI)))
n_users <- dim(movies_UI)[1]
n_items <- dim(movies_UI)[2]
```

# Notations

μˆc on the  slides <=> prob_class[c] with c (class index) an integer
γˆjk on the slides <=> prob_rating[c,j,k] with c (class index), j (movie index / website index) and k (rating) integers


# Step 1: Initiate Parameter Estimates

Choose uniform values for the initial estimates μˆc,γˆjk,c:

```{r}
prob_class <- matrix(1/C, nrow=C)
prob_rating <- array(1/6, dim=c(C, n_items, 6))
assignment <- matrix(NA, nrow=n_users, ncol=C)
```

# Step 2: Expectation Step

Recompute assignment matrix *assignment* for c = 1,2,...,C and i = 1,2,...,n_users:

There's a main issue which is that the formula to update the assignment (slide 42) involves products of many small probabilities (around 0.1). Therefore we quickly reach the smallest float precision in R and the product is approximated to 0 (minimal precision in R is 2e-308). We can't use log to solve this problem since the denominator is a sum....

```{r}
# old fix: subsampling movies

# update_assignment <- function(assignment, prob_class, prob_rating){
#   for (i in 1:n_users){
#     for (c in 1:C){
#       movies_rated_by_i <- which(!is.na(movies_UI[i,]))
#       ratings_given_by_i <- movies_UI[i,!is.na(movies_UI[i,])] 
#       
#       # fix for now: sample some movies instead of all:
#       if (length(movies_rated_by_i) > 100){
#         movies_subsample <- sample(length(movies_rated_by_i),size=100,replace=FALSE)
#         movies_rated_by_i <- movies_rated_by_i[movies_subsample]
#         ratings_given_by_i <- ratings_given_by_i[movies_subsample]
#       }
#       
#       numerator <- prob_class[c]
#       for (k in 1:length(movies_rated_by_i)){
#         numerator <- numerator * prob_rating[c, movies_rated_by_i[[k]], ratings_given_by_i[[k]]]
#       }
#       # print(numerator)
#       denominator <- 0
#       for (l in 1:C){
#         prod <- prob_class[l]
#         for (k in 1:length(movies_rated_by_i)){
#           prod <- prod * prob_rating[l, movies_rated_by_i[[k]], ratings_given_by_i[[k]]]
#         }
#         denominator <- denominator + prod
#       }
#       if (denominator == 0){
#         print('problem')
#         print(c(c,i))
#       }
#       assignment[i, c] <- numerator/denominator
#     }
#   }
#   return(assignment)
# }
```

One solution seems to be scaling prob_rating to mean=1 before computing the products:

```{r}
update_assignment <- function(assignment, prob_class, prob_rating){
  # trick: prob_rating contains floats between 0 and 1
  # since we do a products of a lot of these floats, we'll underflow at some point
  # to fix this scale prob_rating (to mean=1) initially
  # since we're taking ratios eventually this is still correct.
  prob_rating <- prob_rating/mean(prob_rating)
  for (i in 1:n_users){
    movies_rated_by_i <- which(!is.na(movies_UI[i,]))
    ratings_given_by_i <- movies_UI[i,!is.na(movies_UI[i,])]
    
    for (c in 1:C){
      numerator <- prob_class[c]
      for (k in 1:length(movies_rated_by_i)){
        numerator <- numerator * prob_rating[c, movies_rated_by_i[[k]], ratings_given_by_i[[k]]]
      }
      # print(numerator)
      denominator <- 0
      for (l in 1:C){
        prod <- prob_class[l]
        for (k in 1:length(movies_rated_by_i)){
          prod <- prod * prob_rating[l, movies_rated_by_i[[k]], ratings_given_by_i[[k]]]
        }
        denominator <- denominator + prod
      }
      if (denominator == 0 | is.na(denominator)){
        print('problem')
        print(c(c,i))
      }
      if (is.na(numerator)){
        print('problem too')
        print(c(c,i))
      }
      if (is.na(numerator/denominator)){
        print('problem again')
        print(c(c,i))
      }
      assignment[i, c] <- numerator/denominator
    }
  }
  return(assignment)
}
```

# Step 3: Maximization Step

Recompute parameters estimates *prob_class* for c=1..C and *prob_rating* for all c,j,k.

```{r}
update_prob_class <- function(prob_class, assignment){
  for (c in 1:C){
    prob_class[c,] <- sum(assignment[!is.na(assignment[,c]),c])/n_users
  }
  return(prob_class)
}

update_prob_rating <- function(prob_rating, assignment)
  for (c in 1:C){
    for (j in 1:n_items){
      users_who_rated_item_j <- which(!is.na(movies_UI[,j]))
      # print('---------')
      # print(c(c,j))
      # print(users_who_rated_item_j)
      denominator <- sum(assignment[users_who_rated_item_j,c])
      # warning: denominator can be = 0 ! (if prob_class got to 0 for class c at previous step)
      # print(denominator)
      for(k in 1:6){
        if (denominator != 0){
          numerator <- sum((movies_UI[users_who_rated_item_j,j] == k) * assignment[users_who_rated_item_j,c])
          prob_rating[c,j,k] <- numerator/denominator
        } else{
          prob_rating[c,j,k] <- 0
        }
      }
    }
  return(prob_rating)
}
```


# Test the algorithm:

```{r}
prob_class <- matrix(1/C, nrow=C)
prob_rating <- array(1/6, dim=c(C, n_items, 6))
assignment <- matrix(NA, nrow=n_users, ncol=C)

assignment <- update_assignment(assignment, prob_class, prob_rating)
```


```{r}
em <- function(epsilon, max_steps=100){
  step <- 0
  prob_class <- matrix(1/C, nrow=C)
  prob_rating <- array(1/6, dim=c(C, n_items, 6))
  assignment <- matrix(NA, nrow=n_users, ncol=C)

  while (TRUE){
    step <- step + 1
    # E:
    new_assignment <- update_assignment(assignment, prob_class, prob_rating)

    # M:
    new_prob_class <- update_prob_class(prob_class, new_assignment)
    new_prob_rating <- update_prob_rating(prob_rating, new_assignment)
    
    if ((step > 1) & (norm(new_prob_class - prob_class) < epsilon)){
      # convergence: we check if prob_class and prob_rating converge
      # TODO: maybe checking for convergence of likelihood would be better ?
      print(paste0('converged in ', step, ' steps.'))
      return(list(assignment, prob_class, prob_rating))
    } else if (step > max_steps){
      print('reached max number of steps without converging, returning...')
      return(list(assignment, prob_class, prob_rating))
    }
    
    assignment <- new_assignment
    prob_class <- new_prob_class
    prob_rating <- new_prob_rating
  }
}

system.time(result <- em(0.001))

assignment <- result[[1]]
prob_class <- result[[2]]
prob_rating <- result[[3]]

norm(prob_class)
```


# Check results:

```{r}
for (i in 1:dim(assignment)[1]){
  stopifnot(abs(sum(assignment[i,]) - 1) < 0.001)
}
```

# Compute likelihood of parameters

```{r}
# TODO
```


# Do predictions:

Now that we have approximated all parameters, we can do predictions.

```{r}
movie_test <- read.csv("../data/eachmovie_sample/data_test.csv", as.is = TRUE, header = TRUE)
MS_test <- read.csv("../data/MS_sample/data_test.csv", as.is = TRUE, header = TRUE)
```

```{r}
system.time(MS_UI_test <- MS_data_transform(MS_test))
system.time(movies_UI_test <- movie_data_transform(movie_test))

save(MS_UI_test, file = "../data/ms_UI_test.RData")
save(movies_UI_test, file = "../data/movies_UI_test.RData")
```

To estimate ratings, we first compute assignments of the new users to clusters, with the parameters we learned.
We then compute the probability of giving each rating using the soft assignments
And then compute the expectation of the rating given the probabilities we just computed.

Note that once we optimize the rest of the code (by using matrix operations as often as possible) we can also optimize the prediction part.

```{r}
estimate_rating <- function(i, j, prob_class, prob_rating, movies_UI){
  # estimate rating of user i for item j, given learned parameters
  # in general, movies_UI will actually be movies_UI_test
  movies_rated_by_i <- which(!is.na(movies_UI[i,]))
  ratings_given_by_i <- movies_UI[i,!is.na(movies_UI[i,])]
  
  # Step 1: compute assignment of user i
  assignment <- matrix(0, nrow=3)
  for (c in 1:C){
    numerator <- prob_class[c]
    for (k in 1:length(movies_rated_by_i)){
      numerator <- numerator * prob_rating[c, movies_rated_by_i[[k]], ratings_given_by_i[[k]]]
    }
    denominator <- 0
    for (l in 1:C){
      prod <- prob_class[l]
      for (k in 1:length(movies_rated_by_i)){
        prod <- prod * prob_rating[l, movies_rated_by_i[[k]], ratings_given_by_i[[k]]]
      }
      denominator <- denominator + prod
    }
    assignment[c] <- numerator/denominator
  }

  # Step 2: compute probabilities for each rating
  probs <- matrix(0, nrow=6)
  for (k in 1:6){
    for (c in 1:C){
      probs[k] = probs[k] + assignment[c] * prob_rating[c, j, k]
    }
  }

  # Step 3: compute expectation
  expected_rating <- 0
  for (k in 1:6){
    expected_rating <- expected_rating + k*probs[k]
  }
  
  return(expected_rating)
}
```

```{r}
estimate_rating(1, 1, prob_class, prob_rating, movies_UI_test)
```


---
title: "Experiments on dataset and EM"
output: html_notebook
---

This notebook contains some experiments to figure out how the dataset will be used (based on in-class tutorials), and how we'll implement the EM algorithm to compute the clusters.

```{r}
source("../lib/functions.R")
```

```{r}
# not using setwd() since yu don't need to if you open the file from RStudio
# load(file="../data/MS_UI.RData")
# This MS_UI for now has only 3 sample users computed in tutorial
```


```{r}
movie_train <- read.csv("../data/eachmovie_sample/data_train.csv", as.is = TRUE, header = TRUE)
MS_train <- read.csv("../data/MS_sample/data_train.csv", as.is = TRUE, header = TRUE)
```

```{r}
system.time(MS_UI <- MS_data_transform(MS_train))
system.time(movies_UI <- movie_data_transform(movie_train))

save(MS_UI, file = "../data/ms_UI.RData")
save(movies_UI, file = "../data/movies_UI.RData")
```

```{r}
load("../data/ms_UI.RData")
load("../data/movies_UI.RData")
```


```{r}
dim(movies_UI)
```

# Important note

Each row of the matrix movies_UI corresponds to a user. Yet, not all users are in this matrix.
If we access a row through movies_UI[i,] with i an integer, we will get the ratings for the ith user in the matrix, not user number i.
If we want to access this user's rating correctly, we need to use a string instead:

```{r}
head(movies_UI)
movies_UI[2,] # gives ratings of 2nd user in matrix which is in fact user 23
movies_UI["23",] # gives ratings of user 23 (which is 2nd user in this matrix)
```

We don't have this issue for movies though.



Check if there are movies that have no rating, if it's the case we'll have to deal with these cases:

```{r}
# there's probably a cleaner way to check that
for (j in 1:1619){
  if (all(is.na(movies_UI[,j]))){
    print(j)
  }
}
```

For test purposes we reduce the size of movies_UI:
If we simply shrink the matrix, we might end up with movies that have only NA ratings, so we need to remove them:

```{r}
# same as above, ugly code
movies_UI <- movies_UI[1:500,1:200]
non_na_columns = matrix(TRUE, 200)

for (j in 1:200){
  if (all(is.na(movies_UI[,j]))){
    non_na_columns[j] = FALSE
  }
}

movies_UI <- movies_UI[,which(non_na_columns)]
```


# Hyperparameters

```{r}
C <- 3 # number of classes, will be tuned later
# n_users <- max(as.numeric(rownames(movies_UI)))
n_users <- dim(movies_UI)[1]
n_items <- dim(movies_UI)[2]
```

# Notations

μˆc on the  slides <=> prob_class[c] with c (class index) an integer
γˆjk on the slides <=> prob_rating[c,j,k] with c (class index), j (movie index / website index) and k (rating) integers


# Step 1: Initiate Parameter Estimates

Choose uniform values for the initial estimates μˆc,γˆjk,c:

```{r}
prob_class <- matrix(1/C, nrow=C)
prob_rating <- array(1/6, dim=c(C, n_items, 6))
assignment <- matrix(NA, nrow=n_users, ncol=C)
```

# Step 2: Expectation Step

Recompute assignment matrix *assignment* for c = 1,2,...,C and i = 1,2,...,n_users:

```{r}
# for (i in rownames(movies_UI)){
#   for (c in 1:C){
#     # assginment[strtoi(i),c] <- prob_class[c,]
#     movies_rated_by_i <- which(!is.na(movies_UI[i,]))
#     numerator <- prob_class[c,]*prod(prob_rating[c,movies_rated_by_i,])
#     denominator <- 0
#     for (l in 1:C){
#       denominator <- denominator + prob_class[l]*prod(prob_rating[l,movies_rated_by_i,])
#     }
#     assignment[strtoi(i), c] <- numerator/denominator
#   }
# }
```

```{r}
update_assignment <- function(assignment, prob_class, prob_rating){
  for (i in 1:n_users){
    for (c in 1:C){
      movies_rated_by_i <- which(!is.na(movies_UI[i,]))
      numerator <- prob_class[c,]*prod(prob_rating[c,movies_rated_by_i,])
      denominator <- 0
      for (l in 1:C){
        denominator <- denominator + prob_class[l]*prod(prob_rating[l,movies_rated_by_i,])
      }
      assignment[i, c] <- numerator/denominator
    }
  }
  return(assignment)
}
```


# Step 3: Maximization Step

Recompute parameters estimates *prob_class* for c=1..C and *prob_rating* for all c,j,k.

```{r}
update_prob_class <- function(prob_class, assignment){
  for (c in 1:C){
    prob_class[c,] <- sum(assignment[!is.na(assignment[,c]),c])/n_users
  }
  return(prob_class)
}

update_prob_rating <- function(prob_rating, assignment)
  for (c in 1:C){
    for (j in 1:n_items){
      users_who_rated_item_j <- which(!is.na(movies_UI[,j]))
      # print('---------')
      # print(c(c,j))
      # print(users_who_rated_item_j)
      denominator <- sum(assignment[users_who_rated_item_j,c])
      # warning: denominator can be = 0 ! (if prob_class got to 0 for class c at previous step)
      # print(denominator)
      for(k in 1:6){
        if (denominator != 0){
          numerator <- sum((movies_UI[users_who_rated_item_j,j] == k) * assignment[users_who_rated_item_j,c])
          prob_rating[c,j,k] <- numerator/denominator
        } else{
          prob_rating[c,j,k] <- 0
        }
      }
    }
  return(prob_rating)
}
```


# Test the algorithm:

```{r}
prob_class <- matrix(1/C, nrow=C)
prob_rating <- array(1/6, dim=c(C, n_items, 6))
assignment <- matrix(NA, nrow=n_users, ncol=C)

for (i in 1:10){
  # E:
  assignment <- update_assignment(assignment, prob_class, prob_rating)

  print(assignment)
  # M:
  prob_class <- update_prob_class(prob_class, assignment)
  prob_rating <- update_prob_rating(prob_rating, assignment)
  # print(assignment)
  # print(sum(prob_class))
  # print(sum(prob_rating[1,2,])) #c,j,k
}

prob_class
# prob_rating
# 
# for (c in 1:C){
#   for (j in 1:n_items){
#     print(sum(prob_rating[c,j,]))
#   }
# }

# prob_rating[1,1,1]
```

```{r}
movies_UI[,4]
```


```{r}
dim(prob_rating)
movies_rated_by_i
movies_UI
dim(prob_rating)
```


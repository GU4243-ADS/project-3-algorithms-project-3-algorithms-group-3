---
title: "Project 3 - Main script"
author: "Alek Anichowski, Jerome Kafrouni, Pak Kin Lai, Michael Sheng, Chunzi Wang"
date: "March 5, 2018"
output:
  pdf_document: default
  html_document: default
---

# Load libraries

```{r}
source("../lib/functions.R")
source("../lib/em.R")
source("../lib/model_based_predictions.R")
```

# Load the data

```{r}
# movie_train <- read.csv("../data/eachmovie_sample/data_train.csv", as.is = TRUE, header = TRUE)
# MS_train <- read.csv("../data/MS_sample/data_train.csv", as.is = TRUE, header = TRUE)
```

```{r}
# system.time(MS_UI <- MS_data_transform(MS_train))
# system.time(movies_UI <- movie_data_transform(movie_train))

# save(MS_UI, file = "../data/ms_UI.RData")
# save(movies_UI, file = "../data/movies_UI.RData")
```

```{r}
load("../data/ms_UI.RData")
load("../data/movies_UI.RData")
```


```{r}
dim(movies_UI)
dim(MS_UI)
```

# Task 1: implementing two models for Collaborative Filtering

## Memory-based approach

```{r}
# TODO
```


## Model-based approach

The main idea is to model the ratings of users by assigning them to latent (uknown) clusters. In each cluster, we make the assumption that users rate movies similarly. We also make a Naive Bayes assumption over all the movies each user rates.

To compute assignment to unknown clusters, we use the EM algorithm.

To choose the number of clusters (which is an input of the EM algorithm), we use Cross Validation.

### Step 1: Run the EM algorithm to estimate parameters:

- *assignment* corresponds to the M matrix on the tutorial's slides (or the a_i_c values)
- *prob_class* corresponds to the mu_c values (probability of each class)
- *prob_rating* corresponds to the gamma_c_j_k values (prob_rating[class c, movie j, rating k])

**TODO**: Implement Cross Validation to choose C.

```{r}
system.time(result <- em(movies_UI, C=10, epsilon=0.001))

assignment <- result[[1]]
prob_class <- result[[2]]
prob_rating <- result[[3]]
```

### Step 2: Check results:

Check if probabilities are correct:

```{r}
for (i in 1:dim(assignment)[1]){
  stopifnot(abs(sum(assignment[i,]) - 1) < 0.001)
}

stopifnot(abs(sum(prob_class) - 1) < 0.001)

for (c in 1:dim(prob_rating)[1]){
  for (j in 1:dim(prob_rating)[2]){
    # stopifnot(abs(sum(prob_rating[c,j,]) - 1) < 0.001)
    if (abs(sum(prob_rating[c,j,]) - 1) > 0.001){
      print(c(c,j))
    }
  }
}

# there appears to be an error on one of the rows:
# TODO check this further
sum(prob_rating[1,1610,])
```

Compute likelihood of parameters:

```{r}
# TODO
```

### Step 3: Predict ratings

```{r}
system.time(predicted_movies_UI <- predict_all_v2(movies_UI, prob_class, prob_rating, assignment))
```

### Step 4: Measure performance on test data

The test data contains some ratings that were missing for users. We can compare our predictions with these values.

```{r}
# movie_test <- read.csv("../data/eachmovie_sample/data_test.csv", as.is = TRUE, header = TRUE)
# MS_test <- read.csv("../data/MS_sample/data_test.csv", as.is = TRUE, header = TRUE)
```

```{r}
# system.time(MS_UI_test <- MS_data_transform(MS_test))
# system.time(movies_UI_test <- movie_data_transform(movie_test))

# save(MS_UI_test, file = "../data/MS_UI_test.RData")
# save(movies_UI_test, file = "../data/movies_UI_test.RData")
```

```{r}
load("../data/MS_UI_test.RData")
load("../data/movies_UI_test.RData")
```

**TODO**: figure out why the dimensions of test matrices are different, in particular movies_UI_test is missing 22 columns ?

```{r}
dim(MS_UI_test)
dim(MS_UI)

dim(movies_UI_test)
dim(movies_UI)
```

```{r}
indices_to_predict <- which(!is.na(movies_UI_test))
```


Mean squared error, mean absolute error:

```{r}
MSE <- sum((predicted_movies_UI[indices_to_predict] - movies_UI_test[indices_to_predict])**2)/length(indices_to_predict)
MAE <- sum(abs(predicted_movies_UI[indices_to_predict] - movies_UI_test[indices_to_predict]))/length(indices_to_predict)

print(MSE)
print(MAE)
```

R^2 score (coefficient of determination, 1 is best, can be negative, usually between 0 and 1 and quite close to 1).

```{r}
R2 <- 1 - sum((predicted_movies_UI[indices_to_predict] - movies_UI_test[indices_to_predict])**2)/sum((movies_UI_test[indices_to_predict] - mean(movies_UI_test[indices_to_predict]))**2)

print(R2)
```
